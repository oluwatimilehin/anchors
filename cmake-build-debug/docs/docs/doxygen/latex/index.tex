\label{index_md__mnt_c_Users_user_Google_Drive_CodeProjects_anchors_README}%
\Hypertarget{index_md__mnt_c_Users_user_Google_Drive_CodeProjects_anchors_README}%
 Anchors is a C++ library for \href{https://lord.io/spreadsheets/}{\texttt{ self-\/adjusting computations}} based on \href{https://github.com/lord/anchors}{\texttt{ lord/anchors}} for rust and \href{https://github.com/janestreet/incremental}{\texttt{ janestreet/incremental}} for OCaml.

It allows you model complex computations as a DAG which will update efficiently in response to an input change.\hypertarget{index_autotoc_md1}{}\doxysection{Usage}\label{index_autotoc_md1}
An {\ttfamily Anchor} represents a node in the graph (or think of it like a cell in a spreadsheet) and you can define an updater function to create an {\ttfamily Anchor} from one or more Anchors.

As a basic example, let\textquotesingle{}s define an {\ttfamily Anchor} whose value is the sum of two other anchors.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using namespace }anchors;}
\DoxyCodeLine{}
\DoxyCodeLine{Engine d\_engine; \textcolor{comment}{// First set up the anchors engine}}
\DoxyCodeLine{}
\DoxyCodeLine{AnchorPtr<int> anchorA(Anchors::create(2));}
\DoxyCodeLine{AnchorPtr<int> anchorB(Anchors::create(3));}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto} sum = [](\textcolor{keywordtype}{int} a, \textcolor{keywordtype}{int} b) \{ \textcolor{keywordflow}{return} a + b; \};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto} anchorC(Anchors::map2<int>(anchorA, anchorB, sum)); \textcolor{comment}{// Note that the function will not be called until you `get` the value of `anchorC`.}}

\end{DoxyCode}


Anchors follows a demand-\/driven model and will only (re)compute the value of an {\ttfamily Anchor} if you observe the {\ttfamily Anchor}. That is, only observed {\ttfamily Anchor} nodes are guaranteed to return their latest value.


\begin{DoxyCode}{0}
\DoxyCodeLine{d\_engine.observe(anchorC);}
\DoxyCodeLine{EXPECT\_EQ(d\_engine.get(anchorC), 5);}

\end{DoxyCode}


If you update the value of an {\ttfamily Anchor} that an observed {\ttfamily Anchor} depends on, subsequent calls for the observed {\ttfamily Anchor} will return the updated value.


\begin{DoxyCode}{0}
\DoxyCodeLine{d\_engine.set(anchorA, 10);}
\DoxyCodeLine{EXPECT\_EQ(d\_engine.get(anchorC), 13);}

\end{DoxyCode}
\hypertarget{index_autotoc_md2}{}\doxysubsection{More Examples}\label{index_autotoc_md2}
\hypertarget{index_autotoc_md3}{}\doxysubsection{String Concatenation}\label{index_autotoc_md3}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} username(Anchors::create(std::string(\textcolor{stringliteral}{"{}John"{}})));}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto} concatenate = [](\textcolor{keyword}{const} std::string\& text) \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Hello, "{}} + text; \};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto} greeting(Anchors::map<std::string>(username, concatenate));}
\DoxyCodeLine{}
\DoxyCodeLine{d\_engine.observe(greeting);}
\DoxyCodeLine{}
\DoxyCodeLine{EXPECT\_EQ(\textcolor{stringliteral}{"{}Hello, John"{}}, d\_engine.get(greeting));}
\DoxyCodeLine{}
\DoxyCodeLine{d\_engine.set(username, std::string(\textcolor{stringliteral}{"{}Samuel"{}}));}
\DoxyCodeLine{EXPECT\_EQ(\textcolor{stringliteral}{"{}Hello, Samuel"{}}, d\_engine.get(greeting));}

\end{DoxyCode}
\hypertarget{index_autotoc_md4}{}\doxysubsubsection{Using an Input of a Different Type}\label{index_autotoc_md4}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Create the different anchors.}}
\DoxyCodeLine{\textcolor{comment}{// `maxOrder` and `minOrder` accept a vector and return an integer}}
\DoxyCodeLine{\textcolor{keyword}{auto} myOrders = Anchors::create(std::vector<int>\{150, 200, 300\});}
\DoxyCodeLine{}
\DoxyCodeLine{AnchorPtr<int> maxOrder = Anchors::map<int, std::vector<int>>(}
\DoxyCodeLine{        myOrders, [](\textcolor{keyword}{const} std::vector<int>\& v) \{}
\DoxyCodeLine{            \textcolor{keywordflow}{return} *std::max\_element(v.begin(), v.end());}
\DoxyCodeLine{        \});}
\DoxyCodeLine{}
\DoxyCodeLine{AnchorPtr<int> minOrder = Anchors::map<int, std::vector<int>>(}
\DoxyCodeLine{        myOrders, [](\textcolor{keyword}{const} std::vector<int>\& v) \{}
\DoxyCodeLine{            \textcolor{keywordflow}{return} *std::min\_element(v.begin(), v.end());}
\DoxyCodeLine{        \});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// `orderRange` depends on two derived anchors. None of the values will be computed until you call `get`.}}
\DoxyCodeLine{AnchorPtr<int> orderRange = Anchors::map2<int>(}
\DoxyCodeLine{        maxOrder, minOrder, [](\textcolor{keywordtype}{int} max, \textcolor{keywordtype}{int} min) \{ \textcolor{keywordflow}{return} max -\/ min; \});}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Observe multiple anchors at a time. }}
\DoxyCodeLine{\textcolor{comment}{// Note that `orderRange` will still return the correct values below if you do not observe `maxOrder` and `minOrder`.}}
\DoxyCodeLine{\textcolor{comment}{// However, their values will be undefined unless you call `get` for the unobserved values after `orderRange` has been computed.}}
\DoxyCodeLine{std::vector<AnchorPtr<int>> anchorsToObserve\{}
\DoxyCodeLine{        maxOrder, minOrder, orderRange\};}
\DoxyCodeLine{}
\DoxyCodeLine{d\_engine.observe(anchorsToObserve);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Verify the expected values}}
\DoxyCodeLine{EXPECT\_EQ(d\_engine.get(maxOrder), 300);}
\DoxyCodeLine{EXPECT\_EQ(d\_engine.get(minOrder), 150);}
\DoxyCodeLine{EXPECT\_EQ(d\_engine.get(orderRange), 150);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Update the input list and re-\/verify}}
\DoxyCodeLine{d\_engine.set(myOrders, \{300, 400, 800\});}
\DoxyCodeLine{}
\DoxyCodeLine{EXPECT\_EQ(d\_engine.get(maxOrder), 800);}
\DoxyCodeLine{EXPECT\_EQ(d\_engine.get(minOrder), 300);}
\DoxyCodeLine{EXPECT\_EQ(d\_engine.get(orderRange), 500);}

\end{DoxyCode}
\hypertarget{index_autotoc_md5}{}\doxysubsubsection{Verifying That It Avoids Needless Computations}\label{index_autotoc_md5}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Given an Anchor `result`, whose value is derived from (W + X) -\/ Z, }}
\DoxyCodeLine{\textcolor{comment}{// Anchors will not recompute the sum if only the value of Z changes after we have first computed `result`.}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto} anchorW(Anchors::create(10));}
\DoxyCodeLine{\textcolor{keyword}{auto} anchorX(Anchors::create(4));}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int}  additionCounter = 0;}
\DoxyCodeLine{\textcolor{keyword}{auto} anchorY(}
\DoxyCodeLine{    Anchors::map2<int>(anchorW, anchorX, [\&additionCounter](\textcolor{keywordtype}{int} a, \textcolor{keywordtype}{int} b) \{}
\DoxyCodeLine{        additionCounter++;}
\DoxyCodeLine{        \textcolor{keywordflow}{return} a + b;}
\DoxyCodeLine{    \}));}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto} anchorZ(Anchors::create(5));}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int}  subtractionCounter = 0;}
\DoxyCodeLine{\textcolor{keyword}{auto} result(}
\DoxyCodeLine{    Anchors::map2<int>(anchorY, anchorZ, [\&subtractionCounter](\textcolor{keywordtype}{int} a, \textcolor{keywordtype}{int} b) \{}
\DoxyCodeLine{        subtractionCounter++;}
\DoxyCodeLine{        \textcolor{keywordflow}{return} a -\/ b;}
\DoxyCodeLine{    \}));}
\DoxyCodeLine{}
\DoxyCodeLine{d\_engine.observe(result);}
\DoxyCodeLine{}
\DoxyCodeLine{EXPECT\_EQ(d\_engine.get(result), 9);}
\DoxyCodeLine{EXPECT\_EQ(additionCounter, 1);}
\DoxyCodeLine{EXPECT\_EQ(subtractionCounter, 1);}
\DoxyCodeLine{}
\DoxyCodeLine{d\_engine.set(anchorZ, 7);}
\DoxyCodeLine{}
\DoxyCodeLine{EXPECT\_EQ(d\_engine.get(result), 7);}
\DoxyCodeLine{EXPECT\_EQ(additionCounter,1);  \textcolor{comment}{// It shouldn't recompute anchorY because its value did not change}}
\DoxyCodeLine{EXPECT\_EQ(subtractionCounter, 2);}

\end{DoxyCode}
\hypertarget{index_autotoc_md6}{}\doxysubsection{Note}\label{index_autotoc_md6}

\begin{DoxyItemize}
\item When you {\ttfamily get} an observed node, it will bring any other \char`\"{}stale\char`\"{} observed nodes up to date. An observed node is stale if any of its input has changed since it was last brought up to date.
\end{DoxyItemize}\hypertarget{index_autotoc_md7}{}\doxysection{Installation}\label{index_autotoc_md7}
\hypertarget{index_autotoc_md8}{}\doxysection{Roadmap}\label{index_autotoc_md8}
This is still a work in progress, and some tasks I intend to work on in the near future are\+:


\begin{DoxyItemize}
\item Implement \href{https://lord.io/spreadsheets/}{\texttt{ lord/anchors}} optimization -\/ scroll to \char`\"{}anchors, a hybrid solution\char`\"{}.
\item Implement a {\ttfamily set\+Updater()} function that allows you change the updater function for an {\ttfamily Anchor}.
\item Add support for an \href{https://ocaml.janestreet.com/ocaml-core/latest/doc/incremental/Incremental__/Incremental_intf/\#bind}{\texttt{ Incremental.\+bind}} equivalent.
\item Support caching input parameters.
\item Support for {\ttfamily map3}, {\ttfamily map4}, etc.
\item More tests. 
\end{DoxyItemize}