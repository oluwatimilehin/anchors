<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.3" xml:lang="en-US">
  <compounddef id="README_8md" kind="file" language="Markdown">
    <compoundname>README.md</compoundname>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#<sp/>Anchors</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Anchors<sp/>is<sp/>a<sp/>C++<sp/>library<sp/>for<sp/>[self-adjusting<sp/>computations](https://lord.io/spreadsheets/)<sp/>based</highlight></codeline>
<codeline><highlight class="normal">on<sp/>[lord/anchors](https://github.com/lord/anchors)<sp/>for<sp/>rust</highlight></codeline>
<codeline><highlight class="normal">and<sp/>[janestreet/incremental](https://github.com/janestreet/incremental)<sp/>for<sp/>OCaml.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">It<sp/>allows<sp/>you<sp/>model<sp/>complex<sp/>computations<sp/>as<sp/>a<sp/>DAG<sp/>which<sp/>will<sp/>update<sp/>efficiently<sp/>in<sp/>response<sp/>to<sp/>an<sp/>input<sp/>change.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Usage</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">An<sp/>`Anchor`<sp/>represents<sp/>a<sp/>node<sp/>in<sp/>the<sp/>graph<sp/>(or<sp/>think<sp/>of<sp/>it<sp/>like<sp/>a<sp/>cell<sp/>in<sp/>a<sp/>spreadsheet)<sp/>and<sp/>you<sp/>can<sp/>define<sp/>an<sp/>updater</highlight></codeline>
<codeline><highlight class="normal">function<sp/>to<sp/>create<sp/>an<sp/>`Anchor`<sp/>from<sp/>one<sp/>or<sp/>more<sp/>Anchors.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">As<sp/>a<sp/>basic<sp/>example,<sp/>let&apos;s<sp/>define<sp/>an<sp/>`Anchor`<sp/>whose<sp/>value<sp/>is<sp/>the<sp/>sum<sp/>of<sp/>two<sp/>other<sp/>anchors.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">````cpp</highlight></codeline>
<codeline><highlight class="normal">using<sp/>namespace<sp/>anchors;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Engine<sp/>d_engine;<sp/>//<sp/>First<sp/>set<sp/>up<sp/>the<sp/>anchors<sp/>engine</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">AnchorPtr&lt;int&gt;<sp/>anchorA(Anchors::create(2));</highlight></codeline>
<codeline><highlight class="normal">AnchorPtr&lt;int&gt;<sp/>anchorB(Anchors::create(3));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">auto<sp/>sum<sp/>=<sp/>[](int<sp/>a,<sp/>int<sp/>b)<sp/>{<sp/>return<sp/>a<sp/>+<sp/>b;<sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">auto<sp/>anchorC(Anchors::map2&lt;int&gt;(anchorA,<sp/>anchorB,<sp/>sum));<sp/>//<sp/>Note<sp/>that<sp/>the<sp/>function<sp/>will<sp/>not<sp/>be<sp/>called<sp/>until<sp/>you<sp/>`get`<sp/>the<sp/>value<sp/>of<sp/>`anchorC`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">````</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Anchors<sp/>follows<sp/>a<sp/>demand-driven<sp/>model<sp/>and<sp/>will<sp/>only<sp/>(re)compute<sp/>the<sp/>value<sp/>of<sp/>an<sp/>`Anchor`<sp/>if<sp/>you<sp/>observe<sp/>the<sp/>`Anchor`.</highlight></codeline>
<codeline><highlight class="normal">That<sp/>is,<sp/>only<sp/>observed<sp/>`Anchor`<sp/>nodes<sp/>are<sp/>guaranteed<sp/>to<sp/>return<sp/>their<sp/>latest<sp/>value.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">````cpp</highlight></codeline>
<codeline><highlight class="normal">d_engine.observe(anchorC);</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(d_engine.get(anchorC),<sp/>5);</highlight></codeline>
<codeline><highlight class="normal">````</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>update<sp/>the<sp/>value<sp/>of<sp/>an<sp/>`Anchor`<sp/>that<sp/>an<sp/>observed<sp/>`Anchor`<sp/>depends<sp/>on,<sp/>subsequent<sp/>calls<sp/>for<sp/>the<sp/>observed<sp/>`Anchor`</highlight></codeline>
<codeline><highlight class="normal">will<sp/>return<sp/>the<sp/>updated<sp/>value.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">````cpp</highlight></codeline>
<codeline><highlight class="normal">d_engine.set(anchorA,<sp/>10);</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(d_engine.get(anchorC),<sp/>13);</highlight></codeline>
<codeline><highlight class="normal">````</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>More<sp/>Examples</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>String<sp/>Concatenation</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">````cpp</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>username(Anchors::create(std::string(&quot;John&quot;)));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">auto<sp/>concatenate<sp/>=<sp/>[](const<sp/>std::string&amp;<sp/>text)<sp/>{<sp/>return<sp/>&quot;Hello,<sp/>&quot;<sp/>+<sp/>text;<sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">auto<sp/>greeting(Anchors::map&lt;std::string&gt;(username,<sp/>concatenate));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">d_engine.observe(greeting);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">EXPECT_EQ(&quot;Hello,<sp/>John&quot;,<sp/>d_engine.get(greeting));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">d_engine.set(username,<sp/>std::string(&quot;Samuel&quot;));</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(&quot;Hello,<sp/>Samuel&quot;,<sp/>d_engine.get(greeting));</highlight></codeline>
<codeline><highlight class="normal">````</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">####<sp/>Using<sp/>an<sp/>Input<sp/>of<sp/>a<sp/>Different<sp/>Type</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">````cpp</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Create<sp/>the<sp/>different<sp/>anchors.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>`maxOrder`<sp/>and<sp/>`minOrder`<sp/>accept<sp/>a<sp/>vector<sp/>and<sp/>return<sp/>an<sp/>integer</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>myOrders<sp/>=<sp/>Anchors::create(std::vector&lt;int&gt;{150,<sp/>200,<sp/>300});</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">AnchorPtr&lt;int&gt;<sp/>maxOrder<sp/>=<sp/>Anchors::map&lt;int,<sp/>std::vector&lt;int&gt;&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>myOrders,<sp/>[](const<sp/>std::vector&lt;int&gt;&amp;<sp/>v)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>*std::max_element(v.begin(),<sp/>v.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">AnchorPtr&lt;int&gt;<sp/>minOrder<sp/>=<sp/>Anchors::map&lt;int,<sp/>std::vector&lt;int&gt;&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>myOrders,<sp/>[](const<sp/>std::vector&lt;int&gt;&amp;<sp/>v)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>*std::min_element(v.begin(),<sp/>v.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>`orderRange`<sp/>depends<sp/>on<sp/>two<sp/>derived<sp/>anchors.<sp/>None<sp/>of<sp/>the<sp/>values<sp/>will<sp/>be<sp/>computed<sp/>until<sp/>you<sp/>call<sp/>`get`.</highlight></codeline>
<codeline><highlight class="normal">AnchorPtr&lt;int&gt;<sp/>orderRange<sp/>=<sp/>Anchors::map2&lt;int&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>maxOrder,<sp/>minOrder,<sp/>[](int<sp/>max,<sp/>int<sp/>min)<sp/>{<sp/>return<sp/>max<sp/>-<sp/>min;<sp/>});</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Observe<sp/>multiple<sp/>anchors<sp/>at<sp/>a<sp/>time.<sp/></highlight></codeline>
<codeline><highlight class="normal">//<sp/>Note<sp/>that<sp/>`orderRange`<sp/>will<sp/>still<sp/>return<sp/>the<sp/>correct<sp/>values<sp/>below<sp/>if<sp/>you<sp/>do<sp/>not<sp/>observe<sp/>`maxOrder`<sp/>and<sp/>`minOrder`.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>However,<sp/>their<sp/>values<sp/>will<sp/>be<sp/>undefined<sp/>unless<sp/>you<sp/>call<sp/>`get`<sp/>for<sp/>the<sp/>unobserved<sp/>values<sp/>after<sp/>`orderRange`<sp/>has<sp/>been<sp/>computed.</highlight></codeline>
<codeline><highlight class="normal">std::vector&lt;AnchorPtr&lt;int&gt;&gt;<sp/>anchorsToObserve{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>maxOrder,<sp/>minOrder,<sp/>orderRange};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">d_engine.observe(anchorsToObserve);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Verify<sp/>the<sp/>expected<sp/>values</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(d_engine.get(maxOrder),<sp/>300);</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(d_engine.get(minOrder),<sp/>150);</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(d_engine.get(orderRange),<sp/>150);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Update<sp/>the<sp/>input<sp/>list<sp/>and<sp/>re-verify</highlight></codeline>
<codeline><highlight class="normal">d_engine.set(myOrders,<sp/>{300,<sp/>400,<sp/>800});</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">EXPECT_EQ(d_engine.get(maxOrder),<sp/>800);</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(d_engine.get(minOrder),<sp/>300);</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(d_engine.get(orderRange),<sp/>500);</highlight></codeline>
<codeline><highlight class="normal">````</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">####<sp/>Verifying<sp/>That<sp/>It<sp/>Avoids<sp/>Needless<sp/>Computations</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">````cpp</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Given<sp/>an<sp/>Anchor<sp/>`result`,<sp/>whose<sp/>value<sp/>is<sp/>derived<sp/>from<sp/>(W<sp/>+<sp/>X)<sp/>-<sp/>Z,<sp/></highlight></codeline>
<codeline><highlight class="normal">//<sp/>Anchors<sp/>will<sp/>not<sp/>recompute<sp/>the<sp/>sum<sp/>if<sp/>only<sp/>the<sp/>value<sp/>of<sp/>Z<sp/>changes<sp/>after<sp/>we<sp/>have<sp/>first<sp/>computed<sp/>`result`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">auto<sp/>anchorW(Anchors::create(10));</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>anchorX(Anchors::create(4));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">int<sp/><sp/>additionCounter<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>anchorY(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Anchors::map2&lt;int&gt;(anchorW,<sp/>anchorX,<sp/>[&amp;additionCounter](int<sp/>a,<sp/>int<sp/>b)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>additionCounter++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>a<sp/>+<sp/>b;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">auto<sp/>anchorZ(Anchors::create(5));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">int<sp/><sp/>subtractionCounter<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>result(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Anchors::map2&lt;int&gt;(anchorY,<sp/>anchorZ,<sp/>[&amp;subtractionCounter](int<sp/>a,<sp/>int<sp/>b)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>subtractionCounter++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>a<sp/>-<sp/>b;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">d_engine.observe(result);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">EXPECT_EQ(d_engine.get(result),<sp/>9);</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(additionCounter,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(subtractionCounter,<sp/>1);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">d_engine.set(anchorZ,<sp/>7);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">EXPECT_EQ(d_engine.get(result),<sp/>7);</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(additionCounter,1);<sp/><sp/>//<sp/>It<sp/>shouldn&apos;t<sp/>recompute<sp/>anchorY<sp/>because<sp/>its<sp/>value<sp/>did<sp/>not<sp/>change</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(subtractionCounter,<sp/>2);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">````</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Note</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">-<sp/>When<sp/>you<sp/>`get`<sp/>an<sp/>observed<sp/>node,<sp/>it<sp/>will<sp/>bring<sp/>any<sp/>other<sp/>&quot;stale&quot;<sp/>observed<sp/>nodes<sp/>up<sp/>to<sp/>date.<sp/>An<sp/>observed<sp/>node<sp/>is<sp/>stale</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>any<sp/>of<sp/>its<sp/>input<sp/>has<sp/>changed<sp/>since<sp/>it<sp/>was<sp/>last<sp/>brought<sp/>up<sp/>to<sp/>date.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Installation</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Roadmap</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>is<sp/>still<sp/>a<sp/>work<sp/>in<sp/>progress,<sp/>and<sp/>some<sp/>tasks<sp/>I<sp/>intend<sp/>to<sp/>work<sp/>on<sp/>in<sp/>the<sp/>near<sp/>future<sp/>are:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">-<sp/>Implement<sp/>[lord/anchors](https://lord.io/spreadsheets/)<sp/>optimization<sp/>-<sp/>scroll<sp/>to<sp/>&quot;anchors,<sp/>a<sp/>hybrid<sp/>solution&quot;.</highlight></codeline>
<codeline><highlight class="normal">-<sp/>Implement<sp/>a<sp/>`setUpdater()`<sp/>function<sp/>that<sp/>allows<sp/>you<sp/>change<sp/>the<sp/>updater<sp/>function<sp/>for<sp/>an<sp/>`Anchor`.</highlight></codeline>
<codeline><highlight class="normal">-<sp/>Add<sp/>support<sp/>for</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>an<sp/>[Incremental.bind](https://ocaml.janestreet.com/ocaml-core/latest/doc/incremental/Incremental__/Incremental_intf/#bind)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>equivalent.</highlight></codeline>
<codeline><highlight class="normal">-<sp/>Support<sp/>caching<sp/>input<sp/>parameters.</highlight></codeline>
<codeline><highlight class="normal">-<sp/>Support<sp/>for<sp/>`map3`,<sp/>`map4`,<sp/>etc.</highlight></codeline>
<codeline><highlight class="normal">-<sp/>More<sp/>tests.</highlight></codeline>
    </programlisting>
    <location file="/mnt/c/Users/user/Google Drive/CodeProjects/anchors/README.md"/>
  </compounddef>
</doxygen>
