<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.3" xml:lang="en-US">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>Anchors</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><anchor id="index_1md__mnt_c_Users_user_Google_Drive_CodeProjects_anchors_README"/> Anchors is a C++ library for <ulink url="https://lord.io/spreadsheets/">self-adjusting computations</ulink> based on <ulink url="https://github.com/lord/anchors">lord/anchors</ulink> for rust and <ulink url="https://github.com/janestreet/incremental">janestreet/incremental</ulink> for OCaml.</para>
<para>It allows you model complex computations as a DAG which will update efficiently in response to an input change.</para>
<sect1 id="index_1autotoc_md1">
<title>Usage</title>
<para>An <computeroutput>Anchor</computeroutput> represents a node in the graph (or think of it like a cell in a spreadsheet) and you can define an updater function to create an <computeroutput>Anchor</computeroutput> from one or more Anchors.</para>
<para>As a basic example, let&apos;s define an <computeroutput>Anchor</computeroutput> whose value is the sum of two other anchors.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal">anchors;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Engine<sp/>d_engine;<sp/></highlight><highlight class="comment">//<sp/>First<sp/>set<sp/>up<sp/>the<sp/>anchors<sp/>engine</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">AnchorPtr&lt;int&gt;<sp/>anchorA(Anchors::create(2));</highlight></codeline>
<codeline><highlight class="normal">AnchorPtr&lt;int&gt;<sp/>anchorB(Anchors::create(3));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>sum<sp/>=<sp/>[](</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>a,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>b)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>a<sp/>+<sp/>b;<sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>anchorC(Anchors::map2&lt;int&gt;(anchorA,<sp/>anchorB,<sp/>sum));<sp/></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>the<sp/>function<sp/>will<sp/>not<sp/>be<sp/>called<sp/>until<sp/>you<sp/>`get`<sp/>the<sp/>value<sp/>of<sp/>`anchorC`.</highlight></codeline>
</programlisting></para>
<para>Anchors follows a demand-driven model and will only (re)compute the value of an <computeroutput>Anchor</computeroutput> if you observe the <computeroutput>Anchor</computeroutput>. That is, only observed <computeroutput>Anchor</computeroutput> nodes are guaranteed to return their latest value.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">d_engine.observe(anchorC);</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(d_engine.get(anchorC),<sp/>5);</highlight></codeline>
</programlisting></para>
<para>If you update the value of an <computeroutput>Anchor</computeroutput> that an observed <computeroutput>Anchor</computeroutput> depends on, subsequent calls for the observed <computeroutput>Anchor</computeroutput> will return the updated value.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">d_engine.set(anchorA,<sp/>10);</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(d_engine.get(anchorC),<sp/>13);</highlight></codeline>
</programlisting></para>
<sect2 id="index_1autotoc_md2">
<title>More Examples</title>
</sect2>
<sect2 id="index_1autotoc_md3">
<title>String Concatenation</title>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>username(Anchors::create(std::string(</highlight><highlight class="stringliteral">&quot;John&quot;</highlight><highlight class="normal">)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>concatenate<sp/>=<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string&amp;<sp/>text)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="stringliteral">&quot;Hello,<sp/>&quot;</highlight><highlight class="normal"><sp/>+<sp/>text;<sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>greeting(Anchors::map&lt;std::string&gt;(username,<sp/>concatenate));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">d_engine.observe(greeting);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(</highlight><highlight class="stringliteral">&quot;Hello,<sp/>John&quot;</highlight><highlight class="normal">,<sp/>d_engine.get(greeting));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">d_engine.set(username,<sp/>std::string(</highlight><highlight class="stringliteral">&quot;Samuel&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(</highlight><highlight class="stringliteral">&quot;Hello,<sp/>Samuel&quot;</highlight><highlight class="normal">,<sp/>d_engine.get(greeting));</highlight></codeline>
</programlisting></para>
<sect3 id="index_1autotoc_md4">
<title>Using an Input of a Different Type</title>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>Create<sp/>the<sp/>different<sp/>anchors.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>`maxOrder`<sp/>and<sp/>`minOrder`<sp/>accept<sp/>a<sp/>vector<sp/>and<sp/>return<sp/>an<sp/>integer</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>myOrders<sp/>=<sp/>Anchors::create(std::vector&lt;int&gt;{150,<sp/>200,<sp/>300});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">AnchorPtr&lt;int&gt;<sp/>maxOrder<sp/>=<sp/>Anchors::map&lt;int,<sp/>std::vector&lt;int&gt;&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>myOrders,<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;int&gt;&amp;<sp/>v)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*std::max_element(v.begin(),<sp/>v.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">AnchorPtr&lt;int&gt;<sp/>minOrder<sp/>=<sp/>Anchors::map&lt;int,<sp/>std::vector&lt;int&gt;&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>myOrders,<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;int&gt;&amp;<sp/>v)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*std::min_element(v.begin(),<sp/>v.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>`orderRange`<sp/>depends<sp/>on<sp/>two<sp/>derived<sp/>anchors.<sp/>None<sp/>of<sp/>the<sp/>values<sp/>will<sp/>be<sp/>computed<sp/>until<sp/>you<sp/>call<sp/>`get`.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">AnchorPtr&lt;int&gt;<sp/>orderRange<sp/>=<sp/>Anchors::map2&lt;int&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>maxOrder,<sp/>minOrder,<sp/>[](</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>max,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>min)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>max<sp/>-<sp/>min;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Observe<sp/>multiple<sp/>anchors<sp/>at<sp/>a<sp/>time.<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>`orderRange`<sp/>will<sp/>still<sp/>return<sp/>the<sp/>correct<sp/>values<sp/>below<sp/>if<sp/>you<sp/>do<sp/>not<sp/>observe<sp/>`maxOrder`<sp/>and<sp/>`minOrder`.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>However,<sp/>their<sp/>values<sp/>will<sp/>be<sp/>undefined<sp/>unless<sp/>you<sp/>call<sp/>`get`<sp/>for<sp/>the<sp/>unobserved<sp/>values<sp/>after<sp/>`orderRange`<sp/>has<sp/>been<sp/>computed.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::vector&lt;AnchorPtr&lt;int&gt;&gt;<sp/>anchorsToObserve{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>maxOrder,<sp/>minOrder,<sp/>orderRange};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">d_engine.observe(anchorsToObserve);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Verify<sp/>the<sp/>expected<sp/>values</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(d_engine.get(maxOrder),<sp/>300);</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(d_engine.get(minOrder),<sp/>150);</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(d_engine.get(orderRange),<sp/>150);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Update<sp/>the<sp/>input<sp/>list<sp/>and<sp/>re-verify</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">d_engine.set(myOrders,<sp/>{300,<sp/>400,<sp/>800});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(d_engine.get(maxOrder),<sp/>800);</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(d_engine.get(minOrder),<sp/>300);</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(d_engine.get(orderRange),<sp/>500);</highlight></codeline>
</programlisting></para>
</sect3>
<sect3 id="index_1autotoc_md5">
<title>Verifying That It Avoids Needless Computations</title>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>Given<sp/>an<sp/>Anchor<sp/>`result`,<sp/>whose<sp/>value<sp/>is<sp/>derived<sp/>from<sp/>(W<sp/>+<sp/>X)<sp/>-<sp/>Z,<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Anchors<sp/>will<sp/>not<sp/>recompute<sp/>the<sp/>sum<sp/>if<sp/>only<sp/>the<sp/>value<sp/>of<sp/>Z<sp/>changes<sp/>after<sp/>we<sp/>have<sp/>first<sp/>computed<sp/>`result`.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>anchorW(Anchors::create(10));</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>anchorX(Anchors::create(4));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/>additionCounter<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>anchorY(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Anchors::map2&lt;int&gt;(anchorW,<sp/>anchorX,<sp/>[&amp;additionCounter](</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>a,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>b)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>additionCounter++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>a<sp/>+<sp/>b;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>anchorZ(Anchors::create(5));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/>subtractionCounter<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>result(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Anchors::map2&lt;int&gt;(anchorY,<sp/>anchorZ,<sp/>[&amp;subtractionCounter](</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>a,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>b)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>subtractionCounter++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>a<sp/>-<sp/>b;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">d_engine.observe(result);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(d_engine.get(result),<sp/>9);</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(additionCounter,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(subtractionCounter,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">d_engine.set(anchorZ,<sp/>7);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(d_engine.get(result),<sp/>7);</highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(additionCounter,1);<sp/><sp/></highlight><highlight class="comment">//<sp/>It<sp/>shouldn&apos;t<sp/>recompute<sp/>anchorY<sp/>because<sp/>its<sp/>value<sp/>did<sp/>not<sp/>change</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">EXPECT_EQ(subtractionCounter,<sp/>2);</highlight></codeline>
</programlisting></para>
</sect3>
</sect2>
<sect2 id="index_1autotoc_md6">
<title>Note</title>
<para><itemizedlist>
<listitem><para>When you <computeroutput>get</computeroutput> an observed node, it will bring any other &quot;stale&quot; observed nodes up to date. An observed node is stale if any of its input has changed since it was last brought up to date.</para>
</listitem></itemizedlist>
</para>
</sect2>
</sect1>
<sect1 id="index_1autotoc_md7">
<title>Installation</title>
</sect1>
<sect1 id="index_1autotoc_md8">
<title>Roadmap</title>
<para>This is still a work in progress, and some tasks I intend to work on in the near future are:</para>
<para><itemizedlist>
<listitem><para>Implement <ulink url="https://lord.io/spreadsheets/">lord/anchors</ulink> optimization - scroll to &quot;anchors, a hybrid solution&quot;.</para>
</listitem><listitem><para>Implement a <computeroutput>setUpdater()</computeroutput> function that allows you change the updater function for an <computeroutput>Anchor</computeroutput>.</para>
</listitem><listitem><para>Add support for an <ulink url="https://ocaml.janestreet.com/ocaml-core/latest/doc/incremental/Incremental__/Incremental_intf/#bind">Incremental.bind</ulink> equivalent.</para>
</listitem><listitem><para>Support caching input parameters.</para>
</listitem><listitem><para>Support for <computeroutput>map3</computeroutput>, <computeroutput>map4</computeroutput>, etc.</para>
</listitem><listitem><para>More tests. </para>
</listitem></itemizedlist>
</para>
</sect1>
    </detaileddescription>
    <location file="/mnt/c/Users/user/Google Drive/CodeProjects/anchors/README.md"/>
  </compounddef>
</doxygen>
