<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.3"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Anchors: C++ Library for Self-Adjusting Computations</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init()
    </script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeParagraphLink.init()
    </script>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
            <table cellspacing="0" cellpadding="0">
                <tbody>
                <tr id="projectrow">
                    <td id="projectalign">
                        <div id="projectname">Anchors<span id="projectnumber">&#160;0.1</span>
                        </div>
                        <div id="projectbrief">C++ library for self-adjusting computations</div>
                    </td>
                </tr>
                </tbody>
            </table>
        </div>
        <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Anchors </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md__home_runner_work_anchors_anchors_README"></a> Anchors is a C++ library for <a href="https://lord.io/spreadsheets/">self-adjusting computations</a> based on <a href="https://github.com/lord/anchors">lord/anchors</a> for rust and <a href="https://github.com/janestreet/incremental">janestreet/incremental</a> for OCaml.</p>
<p >It allows you model complex computations as a DAG which will update efficiently in response to an input change.</p>
<p ><a href="https://oluwatimilehin.github.io/anchors/">API Documentation</a></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Usage</h1>
<p >An <code>Anchor</code> represents a node in the graph (or think of it like a cell in a spreadsheet) and you can define an updater function to create an <code>Anchor</code> from one or more Anchors.</p>
<p >As a basic example, let's define an <code>Anchor</code> whose value is the sum of two other anchors.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;anchors/anchorutil.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;anchors/engine.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>anchors;</div>
<div class="line"> </div>
<div class="line">Engine d_engine; <span class="comment">// First set up the anchors engine</span></div>
<div class="line"> </div>
<div class="line">AnchorPtr&lt;int&gt; anchorA(Anchors::create(2));</div>
<div class="line">AnchorPtr&lt;int&gt; anchorB(Anchors::create(3));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> sum = [](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) { <span class="keywordflow">return</span> a + b; };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> anchorC(Anchors::map2&lt;int&gt;(anchorA, anchorB, sum)); <span class="comment">// Note that the function will not be called until you `get` the value of `anchorC`.</span></div>
</div><!-- fragment --><p >Anchors follows a demand-driven model and will only (re)compute the value of an <code>Anchor</code> if you observe the <code>Anchor</code>. That is, only observed <code>Anchor</code> nodes are guaranteed to return their latest value.</p>
<div class="fragment"><div class="line">d_engine.observe(anchorC);</div>
<div class="line">EXPECT_EQ(d_engine.get(anchorC), 5);</div>
</div><!-- fragment --><p >If you update the value of an <code>Anchor</code> that an observed <code>Anchor</code> depends on, subsequent calls for the observed <code>Anchor</code> will return the updated value.</p>
<div class="fragment"><div class="line">d_engine.set(anchorA, 10);</div>
<div class="line">EXPECT_EQ(d_engine.get(anchorC), 13);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2"></a>
More Examples</h2>
<h3><a class="anchor" id="autotoc_md3"></a>
String Concatenation</h3>
<div class="fragment"><div class="line"><span class="keyword">auto</span> username(Anchors::create(std::string(<span class="stringliteral">&quot;John&quot;</span>)));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> concatenate = [](<span class="keyword">const</span> std::string&amp; text) { <span class="keywordflow">return</span> <span class="stringliteral">&quot;Hello, &quot;</span> + text; };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> greeting(Anchors::map&lt;std::string&gt;(username, concatenate));</div>
<div class="line"> </div>
<div class="line">d_engine.observe(greeting);</div>
<div class="line"> </div>
<div class="line">EXPECT_EQ(<span class="stringliteral">&quot;Hello, John&quot;</span>, d_engine.get(greeting));</div>
<div class="line"> </div>
<div class="line">d_engine.set(username, std::string(<span class="stringliteral">&quot;Samuel&quot;</span>));</div>
<div class="line">EXPECT_EQ(<span class="stringliteral">&quot;Hello, Samuel&quot;</span>, d_engine.get(greeting));</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md4"></a>
Using an Input of a Different Type</h3>
<div class="fragment"><div class="line"><span class="comment">// Create the different anchors.</span></div>
<div class="line"><span class="comment">// `maxOrder` and `minOrder` accept a vector and return an integer</span></div>
<div class="line"><span class="keyword">auto</span> myOrders = Anchors::create(std::vector&lt;int&gt;{150, 200, 300});</div>
<div class="line"> </div>
<div class="line">AnchorPtr&lt;int&gt; maxOrder = Anchors::map&lt;int, std::vector&lt;int&gt;&gt;(</div>
<div class="line">        myOrders, [](<span class="keyword">const</span> std::vector&lt;int&gt;&amp; v) {</div>
<div class="line">            <span class="keywordflow">return</span> *std::max_element(v.begin(), v.end());</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">AnchorPtr&lt;int&gt; minOrder = Anchors::map&lt;int, std::vector&lt;int&gt;&gt;(</div>
<div class="line">        myOrders, [](<span class="keyword">const</span> std::vector&lt;int&gt;&amp; v) {</div>
<div class="line">            <span class="keywordflow">return</span> *std::min_element(v.begin(), v.end());</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// `orderRange` depends on two derived anchors. None of the values will be computed until you call `get`.</span></div>
<div class="line">AnchorPtr&lt;int&gt; orderRange = Anchors::map2&lt;int&gt;(</div>
<div class="line">        maxOrder, minOrder, [](<span class="keywordtype">int</span> max, <span class="keywordtype">int</span> min) { <span class="keywordflow">return</span> max - min; });</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Observe multiple anchors at a time. </span></div>
<div class="line"><span class="comment">// Note that `orderRange` will still return the correct values below if you do not observe `maxOrder` and `minOrder`.</span></div>
<div class="line"><span class="comment">// However, their values will be undefined unless you call `get` for the unobserved values after `orderRange` has been computed.</span></div>
<div class="line">std::vector&lt;AnchorPtr&lt;int&gt;&gt; anchorsToObserve{</div>
<div class="line">        maxOrder, minOrder, orderRange};</div>
<div class="line"> </div>
<div class="line">d_engine.observe(anchorsToObserve);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Verify the expected values</span></div>
<div class="line">EXPECT_EQ(d_engine.get(maxOrder), 300);</div>
<div class="line">EXPECT_EQ(d_engine.get(minOrder), 150);</div>
<div class="line">EXPECT_EQ(d_engine.get(orderRange), 150);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Update the input list and re-verify</span></div>
<div class="line">d_engine.set(myOrders, {300, 400, 800});</div>
<div class="line"> </div>
<div class="line">EXPECT_EQ(d_engine.get(maxOrder), 800);</div>
<div class="line">EXPECT_EQ(d_engine.get(minOrder), 300);</div>
<div class="line">EXPECT_EQ(d_engine.get(orderRange), 500);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md5"></a>
Verifying That It Avoids Needless Computations</h3>
<div class="fragment"><div class="line"><span class="comment">// Given an Anchor `result`, whose value is derived from (W + X) - Z, </span></div>
<div class="line"><span class="comment">// Anchors will not recompute the sum if only the value of Z changes after we have first computed `result`.</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> anchorW(Anchors::create(10));</div>
<div class="line"><span class="keyword">auto</span> anchorX(Anchors::create(4));</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span>  additionCounter = 0;</div>
<div class="line"><span class="keyword">auto</span> anchorY(</div>
<div class="line">    Anchors::map2&lt;int&gt;(anchorW, anchorX, [&amp;additionCounter](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {</div>
<div class="line">        additionCounter++;</div>
<div class="line">        <span class="keywordflow">return</span> a + b;</div>
<div class="line">    }));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> anchorZ(Anchors::create(5));</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span>  subtractionCounter = 0;</div>
<div class="line"><span class="keyword">auto</span> result(</div>
<div class="line">    Anchors::map2&lt;int&gt;(anchorY, anchorZ, [&amp;subtractionCounter](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {</div>
<div class="line">        subtractionCounter++;</div>
<div class="line">        <span class="keywordflow">return</span> a - b;</div>
<div class="line">    }));</div>
<div class="line"> </div>
<div class="line">d_engine.observe(result);</div>
<div class="line"> </div>
<div class="line">EXPECT_EQ(d_engine.get(result), 9);</div>
<div class="line">EXPECT_EQ(additionCounter, 1);</div>
<div class="line">EXPECT_EQ(subtractionCounter, 1);</div>
<div class="line"> </div>
<div class="line">d_engine.set(anchorZ, 7);</div>
<div class="line"> </div>
<div class="line">EXPECT_EQ(d_engine.get(result), 7);</div>
<div class="line">EXPECT_EQ(additionCounter,1);  <span class="comment">// It shouldn&#39;t recompute anchorY because its value did not change</span></div>
<div class="line">EXPECT_EQ(subtractionCounter, 2);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md6"></a>
Note</h2>
<ul>
<li>When you <code>get</code> an observed node, it will bring any other "stale" observed nodes up to date. An observed node is stale if any of its input has changed since it was last brought up to date.</li>
</ul>
<h1><a class="anchor" id="autotoc_md7"></a>
Installation</h1>
<p >You can use Anchors from a CMake project by extracting the linked file[TODO] and adding the following:</p>
<div class="fragment"><div class="line"># CMakeLists.txt</div>
<div class="line">list(APPEND CMAKE_PREFIX_PATH &lt;path_to_library_folder)</div>
<div class="line">find_package(Boost REQUIRED) # Anchors requires a Boost installation</div>
<div class="line">find_package(Anchors REQUIRED)</div>
<div class="line">....</div>
<div class="line"> </div>
<div class="line">target_link_libraries(${YOUR_TARGET} PRIVATE Anchors::anchors)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8"></a>
Roadmap</h1>
<p >This is still a work in progress, and some tasks I intend to work on in the near future are:</p>
<ul>
<li>Implement <a href="https://lord.io/spreadsheets/">lord/anchors</a> optimization - scroll to "anchors, a hybrid solution".</li>
<li>Implement a <code>setUpdater()</code> function that allows you change the updater function for an <code>Anchor</code>.</li>
<li>Add support for an <a href="https://ocaml.janestreet.com/ocaml-core/latest/doc/incremental/Incremental__/Incremental_intf/#bind">Incremental.bind</a> equivalent.</li>
<li>Support caching input parameters.</li>
<li>Support for <code>map3</code>, <code>map4</code>, etc.</li>
<li>More tests. </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
